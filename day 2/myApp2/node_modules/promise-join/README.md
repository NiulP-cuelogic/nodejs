# promise-join

Like Promise.all but for objects. Unlike `Promise.all` this will not fail if one promise fails. It will always wait for all promises to complete.

```javascript
const join = require('promise-join')

const results = join({a: Promise.resolve(1)})

results.then(({result, errors}) => {
  result == {a: 1}
  errors == {}
})
```

## Package

* The package will return a function: `typeof require('promise-join') === 'function'`
* The function will resolve all parameter promises and return a promise when completed.

### Parameters

* Accepts a single parameter that must be an object: `require('promise-join')({a: Promise.resolve()})`
* Each key/value pair must be a promise: `const param = {a: Promise.resolve(), b: Promise.resolve()}`

```javascript
const join = require('promise-join')

const goodParams = {
  a: Promise.resolve(1),
  b: Promise.resolve(2)
}

join(goodParams) // this works


const badParams = {
  a: Promise.resolve(1),
  b: 1
}

join(badParams) // this will not work
```

### Results

* Will always return a promise
* promise will always succeed
* promise will always return an object with a `result` & `errors` keys.
* All promises that succeed will be in the result key.
* All promises that fail will be in the failed key.
* The promise will never fail, even if all the parameter promises fail.

```javascript
const join = require('promise-join')

join({a: Promise.resolve(1)}).then(({result, errors}) => {
  result == {a: 1}
  errors == {}
})

const failedPromise = new Promise((resolve, reject) => {
  reject('err')
})

join({failedPromise}).then(({result, errors}) => {
  result == {}
  errors == {failedPromise: 'err'}
})

const params = {
  a: Promise.resolve(1),
  b: failedPromise
}

join(params).then(({result, errors}) => {
  result == {a: 1}
  errors == {failedPromise: 'err'}
})
```
